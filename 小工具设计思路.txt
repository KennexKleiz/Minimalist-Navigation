🎯 改进方案：前端 + 后端双重限流
核心思路
前端 localStorage - 快速反馈，减少无效请求
后端 IP 限流 - 真正的防护，无法绕过
工具级别配置 - 每个工具可以单独设置限制
简单集成 - 小工具只需添加几行代码
📊 推荐方案设计
方案特点
✅ 基于 IP + 工具 ID - 每个工具独立计数
✅ 前端预检查 - localStorage 快速提示，减少服务器压力
✅ 后端强制验证 - IP 限流，无法绕过
✅ 灵活配置 - 管理员可为每个工具设置不同限制
✅ 友好提示 - 显示剩余次数和重置时间
🗄️ 数据库设计（简化版）
// 1. 在 Tool 模型中添加限流配置
model Tool {
  iInt      @id @default(autoincrement())
  name              String
  code              String
  // ... 其他字段
  
  // 新增：AI 限流配置
  enableAILimit     Boolean  @default(false)   // 是否启用限流
  aiDailyLimit      Int      @default(10)      // 每日限制次数
  aiUsageRecords    AIUsageRecord[]
}

// 2. AI 使用记录表（简化版）
model AIUsageRecord {
  id        Int      @id @default(autoincrement())
  toolId    Int?     // 工具 ID（可选）
  tool      Tool?    @relation(fields: [toolId], references: [id], onDelete: Cascade)
  ip        String   // 用户 IP
  count     Int      @default(1)  // 当天调用次数
  date      String   // 日期 YYYY-MM-DD
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@unique([toolId, ip, date])  // 每个工具+IP+日期唯一@@index([ip, date])
}
🔧 API 设计
1. 增强的 AI 调用接口
// POST /api/ai/chat
{
  toolId?: number,        // 新增：工具 ID（可选）
  messages: [...],
  temperature?: number,
  maxTokens?: number
}

// Response
{
  content: string,
  usage: {
    remaining: number,    // 剩余次数
    limit: number,        // 总限制
    resetTime: string     // 重置时间
  }
}

// Error Response (429)
{
  error: "今日调用次数已用完",
  usage: {
    remaining: 0,
    limit: 10,
    resetTime: "2025-01-29T00:00:00.000Z"
  }
}
💻 前端集成方案（改进你的代码）
方案 1：最小改动（推荐）
只需修改你现有代码的 fetch 部分：
// 在你的代码中，只需修改这部分
tryconst res = await fetch('/api/ai/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            toolId: 123,  // ⭐ 新增：工具 ID（在工具编辑器中配置）
            messages: [
                { role: 'system', content: SYSTEM_PROMPT }, 
                { role: 'user', content: input }
            ],
            temperature: 1.0
        })
    });
    
    // ⭐ 处理 429 错误（超限）
    if (res.status === 429) {
        const error = await res.json();
        showRes(`🔥 今日吐槽次数已用完\n明天 ${new Date(error.usage.resetTime).toLocaleTimeString()} 再来！`);
        return;
    }
    
    const data = await res.json();
    const content = data.content || "麦克风坏了";
    // ⭐ 更新剩余次数（从服务器返回）
    if (data.usage)document.getElementById('quota-count').innerText = data.usage.remaining;// 同步到 localStorage（可选）
        let d = { date: new Date().toLocaleDateString(), count: data.usage.limit - data.usage.remaining };
        localStorage.setItem(KEY_QUOTA, JSON.stringify(d));
    }
    
    showRes(content);
} catch(e) { 
    showRes("我笑断气了，稍后再试 (网络错误)"); 
}
方案 2：完整的双重验证
// 1. 页面加载时从服务器获取真实剩余次数
async function initQuota() {
    try {
        const res = await fetch('/api/ai/check-limit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ toolId: 123 })
        });
        const data = await res.json();
        
        // 更新显示
        document.getElementById('quota-count').innerText = data.remaining;
        
        // 同步到 localStorage
        const today = new Date().toLocaleDateString();
        localStorage.setItem(KEY_QUOTA, JSON.stringify({
            date: today,
            count: data.limit - data.remaining,
            limit: data.limit
        }));
        return data.remaining > 0;
    } catch (e) {
        // 网络错误时使用 localStorage 的值
        return updateQuota() > 0;
    }
}

// 2. 修改 updateQuota 函数
function updateQuota() {
    const today = new Date().toLocaleDateString();
    let data = JSON.parse(localStorage.getItem(KEY_QUOTA) || '{}');
    
    // 如果日期变了，重置
    if (data.date !== today) {
        data = { date: today, count: 0, limit: 10 };
    }
    
    const left = Math.max(0, (data.limit || 10) - data.count);
    document.getElementById('quota-count').innerText = left;
    
    if (left === 0) {
        document.getElementById('submit-btn').disabled = true;
    }
    
    return left;
}

// 3. 页面加载时初始化
window.addEventListener('load', () => {
    initQuota();
});

// 4. 提交时的完整逻辑
document.getElementById('submit-btn').onclick = async () => {
    // 前端预检查（快速反馈）
    if (updateQuota() <= 0) {
        alert('今日吐槽次数已用完！明天再来！');
        return;
    }
    
    const input = document.getElementById('user-input').value.trim();
    if (!input) return alert('你不说话我怎么吐槽？');
    
    // ... 显示加载状态 ...
    
    try {
        const res = await fetch('/api/ai/chat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                toolId: 123,  // 工具 ID
                messages: [
                    { role: 'system', content: SYSTEM_PROMPT }, 
                    { role: 'user', content: input }
                ],
                temperature: 1.0
            })
        });
        
        // 处理超限错误
        if (res.status === 429) {
            const error = await res.json();
            showRes(`🔥 今日吐槽次数已用完！\n重置时间：${new Date(error.usage.resetTime).toLocaleString()}`);
            
            // 更新本地状态
            let d = JSON.parse(localStorage.getItem(KEY_QUOTA) || '{}');
            d.count = error.usage.limit;
            localStorage.setItem(KEY_QUOTA, JSON.stringify(d));
            updateQuota();
            return;
        }
        
        const data = await res.json();
        const content = data.content || "麦克风坏了";
        
        // 更新剩余次数（使用服务器返回的真实值）
        if (data.usage) {
            document.getElementById('quota-count').innerText = data.usage.remaining;
            // 同步到 localStorage
            let d = {
                date: new Date().toLocaleDateString(),
                count: data.usage.limit - data.usage.remaining,
                limit: data.usage.limit
            };
            localStorage.setItem(KEY_QUOTA, JSON.stringify(d));
            updateQuota();
        }
        
        showRes(content);
    } catch(e) { 
        showRes("我笑断气了，稍后再试 (网络错误)"); 
    }
    
    // ... 恢复按钮状态 ...
};
🎨 管理后台配置界面
工具编辑页面增强
┌─────────────────────────────────────────┐
│ 编辑工具：AI 毒舌吐槽大│
├─────────────────────────────────────────┤
│ 工具名称：[AI 毒舌吐槽大会]              │
│ 描述：[...]                              │
│ 图标：[🔥]                               │
││
│ ┌─ AI 调用限制 ─────────────────────┐  │
│ │                                    │  │
│ │ ☑ 启用 AI 调用次数限制             │  │
│                    │  │
│ │ 每日限制：[10] 次/IP│  │
│ │                                    │  │
│ │ 💡 提示：                │  │
│ │ - 用户每天最多调用 10 次           │  │
│ │ - 基于 IP 地址限制                 │  │
│ │ - 每天 00:00 自动重置              │  │
│ │                                    │  │
│ │ 📊 今日使用情况：                  │  │
│ │ - 总调用：45 次                    │  │
│ │ - 独立 IP：12 个                   │  │
│ │ - 平均：3.75 次/IP                 │  │
│ │                                    │  │
│ └────────────────────────────────────┘  │
│                                         │
│ [保存] [取消]│
└─────────────────────────────────────────┘
🔄 完整工作流程
1. 用户打开小工具↓
2. 前端调用 initQuota() 获取真实剩余次数
   ├─ 成功 → 显示剩余次数
   └─ 失败 → 使用 localStorage 的值
   ↓
3. 用户输入内容，点击"狠狠吐槽我"
   ↓
4. 前端 localStorage 预检查
   ├─ 已用完 → 立即提示，不发请求
   └─ 还有剩余 → 继续
   ↓
5. 发送请求到 /api/ai/chat（带 toolId）
   ↓
6. 后端验证
   ├─ 检查工具是否启用限流
   ├─ 检查 IP 今日调用次数
   ├─ 超限 → 返回 429 错误
   └─ 未超限 → 继续
   ↓
7. 后端记录使用次数
   ↓
8. 调用 AI 获取结果
   ↓
9. 返回结果 + 剩余次数
   ↓
10. 前端显示结果并更新剩余次数
💡 方案优势
1. 双重保护
前端：快速反馈，减少无效请求
后端：真正防护，无法绕过
2. 用户体验好
实时显示剩余次数
清晰的重置时间提示
前端预检查，响应快
3. 灵活配置
每个工具可以单独设置限制
高成本工具设置低限制（如 5 次）
低成本工具设置高限制（如 20 次）
4. 简单集成
小工具只需添加 toolId 参数
其他代码几乎不用改动
自动处理限流逻辑
🤔 需要确认的问题
限制次数：
默认 10 次/天合适吗？
不同工具需要不同限制吗？
重置时间：
每天 00:00 重置？（推荐）
还是从首次调用开始 24 小时？
超限提示：
简单提示"次数用完，明天再来"？
还是需要引导付费解锁？
工具 ID 获取：
在工具编辑器中显示工具 ID？
还是自动注入到小工具代码中？
统计功能：
需要详细的使用统计吗？
还是只在工具编辑页面显示简单统计？
这个方案结合了你现有的 localStorage 方案和后端 IP 限流，既保证了安全性，又提供了良好的用户体验。你觉得这个方案如何？有什么需要调整的吗？